################################################################################
#
#  List of provided utility functions
#
#  - calculatePercentPV
#  - calculatePowerPV
#  - calculateRatedLoad
#  - calculateTotalPercentPV
#  - calculateVoltageMagnitude
#  - getPCC
#  - selectDownstreamInverters
#  - scalePV
#
################################################################################

def getPCC(gld):
  ''' Obtain the GLD object associated with a particular, statically defined,
      point of common connection '''
  pcc_name = '6209540_2284596'
  return gld.get_all(use_names=True)[pcc_name]

def selectDownstreamInverters(gld, pcc, N, phase):
  ''' Obtain a list of N randomly-chosen inverters that are (i) downstream of
      the PCC and (ii) using the specified phase '''
  import random
  substations = gld.get_all('substation')
  if (len(substations) > 1):
    print("There was more than one substation found... not sure how to specify root of graph")
    return
  tree_root = substations[0]
  tree = gld.get_tree(tree_root)
  inverters = gld.get_all('inverter')
  downstream_inverter_list = []
  search_list = tree[pcc]
  while (len(search_list) > 0):
    for obj in search_list:
      search_list.extend(tree[obj])
      search_list.remove(obj)
      if (phase not in obj.values['phases']):
        continue
      for inverter in inverters:
        if (inverter.values['parent'] == obj.values['name']):
          downstream_inverter_list.append(inverter)
          break
  random.seed(1)
  return random.sample(downstream_inverter_list, N)

def calculateRatedLoad(gld, load):
  ''' Calculate the rated load for a given load, defined as the sum of all
      maximum load values for each phase '''
  import numpy as np
  players = gld.get_all('player', use_names=True)
  ratedLoad = 0.0
  for phase in ['A', 'B', 'C']:
    loadName = 'constant_power_{}_real'.format(phase)
    if (loadName not in load.values):
      continue
    if ('LprofileCom' in load.values[loadName]):
      expression = load.values[loadName].replace('LprofileCom.value*','')
      profileMax = np.amax(players['LprofileCom'].player_profile.dataframe['load'])
    else:
      expression = load.values[loadName].replace('LprofileRes.value*','')
      profileMax = np.amax(players['LprofileRes'].player_profile.dataframe['load'])
    if ('+' in expression):
      words = expression.split('+')
      a = float(words[0])
      b = float(words[1])
    else:
      words = expression.split('-')
      a  = float(words[0])
      b = -float(words[1])
    ratedLoad += a*profileMax + b
  return ratedLoad

def calculateTotalRatedLoad(gld):
  ''' Calculate the total rated load for a given model, defined as the sum of
      all rated load values for each load '''
  loads = gld.get_all('load')
  totalRatedLoad = 0.0
  for load in loads:
    totalRatedLoad += calculateRatedLoad(gld, load)
  return totalRatedLoad

def calculatePowerPV(gld, meter=None):
  ''' computes the approximate power generated by PV (if meter is provided, the
      value will correspond to all solar connected to that meter, otherwise the
      value is for all solar in the grid) '''
  inverters = gld.get_all('inverter', use_names=True)
  if (meter):
    # get PV under pcc
    solar = [pv for pv in gld.get_all('solar')
      if inverters[pv.values['parent']].values['parent'] == meter.values['name']]
  else:
    solar = gld.get_all('solar')

  powerPV = 0.0
  for pv in solar:
    # Official rated insolation per http://gridlab-d.shoutwiki.com/wiki/Solar
    powerPV += 92.902 * float(pv.values['area']) * float(pv.values['efficiency'])
  return powerPV

def calculatePercentPV(gld, load):
  ''' calculate the % of PV relative to the specified load in the model '''
  meters = gld.get_all('meter', use_names=True)
  meter = meters[load.values['parent']]
  powerPV = calculatePowerPV(gld, meter)
  ratedLoad = calculateRatedLoad(gld, load)
  return 100 * powerPV / ratedLoad

def calculateTotalPercentPV(gld):
  ''' calculate the % of PV relative to the total rated load of the model '''
  # calculate total pv / load ratio
  totalPowerPV = calculatePowerPV(gld)
  totalRatedLoad = calculateTotalRatedLoad(gld)
  return 100 * totalPowerPV/totalRatedLoad

def scalePV(gld, percentPV):
  ''' scale all panels such that 100 * (PV power / load) = percentPV / 100 '''
  inverters = gld.get_all('inverter', use_names=True)
  loads = gld.get_all('load')
  meters = gld.get_all('meter', use_names=True)
  solar = gld.get_all('solar')
  for pv in solar:
    pv.values['area'] = 1.0
  for load in loads:
    current = calculatePercentPV(gld, load)
    for pv in solar:
      inverter = inverters[pv.values['parent']]
      meter = meters[inverter.values['parent']]
      if (meter == meters[load.values['parent']]):
        pv.values['area'] *= percentPV/current
  if (abs(percentPV - calculateTotalPercentPV(gld)) > 1e-10):
    raise Exception("target total %PV not reached")
  return gld

def calculateVoltageMagnitude(obj, property):
  ''' calculate the voltage magnitude from the specified property of the
      specified GLD object '''
  import numpy as np
  data = obj.data[property]
  time = data.index.hour + data.index.minute/60
  voltageValues = data.values
  magnitudeValues = np.empty(len(voltageValues))
  for i, voltageValue in enumerate(voltageValues):
    magnitudeValues[i] = np.abs(complex(voltageValue.replace('d','j')))
  return time, magnitudeValues
